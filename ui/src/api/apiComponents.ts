/**
 * Generated by @openapi-codegen
 *
 * @version 1.0
 */
import * as reactQuery from "@tanstack/react-query";
import { useApiContext, ApiContext, queryKeyFn } from "./apiContext";
import { deepMerge } from "./apiUtils";
import type * as Fetcher from "./apiFetcher";
import { apiFetch } from "./apiFetcher";
import type * as Schemas from "./apiSchemas";
import type { ClientErrorStatus, ServerErrorStatus } from "./apiUtils";

type QueryFnOptions = {
  signal?: AbortController["signal"];
};

export type PostUserRegisterError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200 | 400>;
  payload: Schemas.ErrorOUT;
}>;

export type PostUserRegisterVariables = {
  body: Schemas.RegisterIN;
} & ApiContext["fetcherOptions"];

/**
 * Registers and logs in a new user, returning an API key.
 */
export const fetchPostUserRegister = (
  variables: PostUserRegisterVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.RegisterOUT,
    PostUserRegisterError,
    Schemas.RegisterIN,
    {},
    {},
    {}
  >({ url: "/user/register", method: "post", ...variables, signal });

/**
 * Registers and logs in a new user, returning an API key.
 */
export const usePostUserRegister = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.RegisterOUT,
      PostUserRegisterError,
      PostUserRegisterVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.RegisterOUT,
    PostUserRegisterError,
    PostUserRegisterVariables
  >({
    mutationFn: (variables: PostUserRegisterVariables) =>
      fetchPostUserRegister(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostUserLoginError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200 | 400>;
  payload: Schemas.ErrorOUT;
}>;

export type PostUserLoginVariables = {
  body: Schemas.LoginIN;
} & ApiContext["fetcherOptions"];

/**
 * Logs in a user, returning an API key.
 */
export const fetchPostUserLogin = (
  variables: PostUserLoginVariables,
  signal?: AbortSignal,
) =>
  apiFetch<Schemas.LoginOUT, PostUserLoginError, Schemas.LoginIN, {}, {}, {}>({
    url: "/user/login",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Logs in a user, returning an API key.
 */
export const usePostUserLogin = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.LoginOUT,
      PostUserLoginError,
      PostUserLoginVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.LoginOUT,
    PostUserLoginError,
    PostUserLoginVariables
  >({
    mutationFn: (variables: PostUserLoginVariables) =>
      fetchPostUserLogin(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostUserLogoutError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200 | 400>;
  payload: Schemas.ErrorOUT;
}>;

export type PostUserLogoutVariables = {
  body: Schemas.LogoutIN;
} & ApiContext["fetcherOptions"];

/**
 * Logs out a user, invalidating the used API key.
 */
export const fetchPostUserLogout = (
  variables: PostUserLogoutVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.LogoutOUT,
    PostUserLogoutError,
    Schemas.LogoutIN,
    {},
    {},
    {}
  >({ url: "/user/logout", method: "post", ...variables, signal });

/**
 * Logs out a user, invalidating the used API key.
 */
export const usePostUserLogout = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.LogoutOUT,
      PostUserLogoutError,
      PostUserLogoutVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.LogoutOUT,
    PostUserLogoutError,
    PostUserLogoutVariables
  >({
    mutationFn: (variables: PostUserLogoutVariables) =>
      fetchPostUserLogout(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostUserChangepasswordError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200 | 400>;
  payload: Schemas.ErrorOUT;
}>;

export type PostUserChangepasswordVariables = {
  body: Schemas.ChangePasswordIN;
} & ApiContext["fetcherOptions"];

export const fetchPostUserChangepassword = (
  variables: PostUserChangepasswordVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.ChangePasswordOUT,
    PostUserChangepasswordError,
    Schemas.ChangePasswordIN,
    {},
    {},
    {}
  >({ url: "/user/changepassword", method: "post", ...variables, signal });

export const usePostUserChangepassword = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ChangePasswordOUT,
      PostUserChangepasswordError,
      PostUserChangepasswordVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.ChangePasswordOUT,
    PostUserChangepasswordError,
    PostUserChangepasswordVariables
  >({
    mutationFn: (variables: PostUserChangepasswordVariables) =>
      fetchPostUserChangepassword(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetUserError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: Schemas.ErrorOUT;
}>;

export type GetUserVariables = ApiContext["fetcherOptions"];

/**
 * Gets the currently logged in user's information.
 */
export const fetchGetUser = (
  variables: GetUserVariables,
  signal?: AbortSignal,
) =>
  apiFetch<Schemas.GetUserOUT, GetUserError, undefined, {}, {}, {}>({
    url: "/user",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Gets the currently logged in user's information.
 */
export function getUserQuery(variables: GetUserVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.GetUserOUT>;
};

export function getUserQuery(
  variables: GetUserVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.GetUserOUT>)
    | reactQuery.SkipToken;
};

export function getUserQuery(
  variables: GetUserVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/user",
      operationId: "getUser",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetUser(variables, signal),
  };
}

/**
 * Gets the currently logged in user's information.
 */
export const useSuspenseGetUser = <TData = Schemas.GetUserOUT,>(
  variables: GetUserVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.GetUserOUT, GetUserError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useSuspenseQuery<Schemas.GetUserOUT, GetUserError, TData>({
    ...getUserQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Gets the currently logged in user's information.
 */
export const useGetUser = <TData = Schemas.GetUserOUT,>(
  variables: GetUserVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.GetUserOUT, GetUserError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useQuery<Schemas.GetUserOUT, GetUserError, TData>({
    ...getUserQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostUserError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200 | 400>;
  payload: Schemas.ErrorOUT;
}>;

export type PostUserVariables = {
  body: Schemas.UpdateUserIN;
} & ApiContext["fetcherOptions"];

export const fetchPostUser = (
  variables: PostUserVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.UpdateUserOUT,
    PostUserError,
    Schemas.UpdateUserIN,
    {},
    {},
    {}
  >({ url: "/user", method: "post", ...variables, signal });

export const usePostUser = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UpdateUserOUT,
      PostUserError,
      PostUserVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.UpdateUserOUT,
    PostUserError,
    PostUserVariables
  >({
    mutationFn: (variables: PostUserVariables) =>
      fetchPostUser(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostPasswordresetResetError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200 | 400>;
  payload: Schemas.ErrorOUT;
}>;

export type PostPasswordresetResetVariables = {
  body: Schemas.PasswordResetIN;
} & ApiContext["fetcherOptions"];

export const fetchPostPasswordresetReset = (
  variables: PostPasswordresetResetVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.PasswordResetOUT,
    PostPasswordresetResetError,
    Schemas.PasswordResetIN,
    {},
    {},
    {}
  >({ url: "/passwordreset/reset", method: "post", ...variables, signal });

export const usePostPasswordresetReset = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.PasswordResetOUT,
      PostPasswordresetResetError,
      PostPasswordresetResetVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.PasswordResetOUT,
    PostPasswordresetResetError,
    PostPasswordresetResetVariables
  >({
    mutationFn: (variables: PostPasswordresetResetVariables) =>
      fetchPostPasswordresetReset(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostPasswordresetForgotError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200 | 400>;
  payload: Schemas.ErrorOUT;
}>;

export type PostPasswordresetForgotVariables = {
  body: Schemas.ForgotPasswordIN;
} & ApiContext["fetcherOptions"];

export const fetchPostPasswordresetForgot = (
  variables: PostPasswordresetForgotVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.ForgotPasswordOUT,
    PostPasswordresetForgotError,
    Schemas.ForgotPasswordIN,
    {},
    {},
    {}
  >({ url: "/passwordreset/forgot", method: "post", ...variables, signal });

export const usePostPasswordresetForgot = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ForgotPasswordOUT,
      PostPasswordresetForgotError,
      PostPasswordresetForgotVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.ForgotPasswordOUT,
    PostPasswordresetForgotError,
    PostPasswordresetForgotVariables
  >({
    mutationFn: (variables: PostPasswordresetForgotVariables) =>
      fetchPostPasswordresetForgot(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetAdminVersionError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: Schemas.ErrorOUT;
}>;

export type GetAdminVersionVariables = ApiContext["fetcherOptions"];

export const fetchGetAdminVersion = (
  variables: GetAdminVersionVariables,
  signal?: AbortSignal,
) =>
  apiFetch<Schemas.VersionOUT, GetAdminVersionError, undefined, {}, {}, {}>({
    url: "/admin/version",
    method: "get",
    ...variables,
    signal,
  });

export function getAdminVersionQuery(variables: GetAdminVersionVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.VersionOUT>;
};

export function getAdminVersionQuery(
  variables: GetAdminVersionVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.VersionOUT>)
    | reactQuery.SkipToken;
};

export function getAdminVersionQuery(
  variables: GetAdminVersionVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/admin/version",
      operationId: "getAdminVersion",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetAdminVersion(variables, signal),
  };
}

export const useSuspenseGetAdminVersion = <TData = Schemas.VersionOUT,>(
  variables: GetAdminVersionVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.VersionOUT, GetAdminVersionError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.VersionOUT,
    GetAdminVersionError,
    TData
  >({
    ...getAdminVersionQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetAdminVersion = <TData = Schemas.VersionOUT,>(
  variables: GetAdminVersionVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.VersionOUT, GetAdminVersionError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useQuery<Schemas.VersionOUT, GetAdminVersionError, TData>({
    ...getAdminVersionQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type QueryOperation =
  | {
      path: "/user";
      operationId: "getUser";
      variables: GetUserVariables | reactQuery.SkipToken;
    }
  | {
      path: "/admin/version";
      operationId: "getAdminVersion";
      variables: GetAdminVersionVariables | reactQuery.SkipToken;
    };
